#!/usr/bin/env python3
"""
Generate AmbianceSound.swift from ambiance_sounds.json

This script reads the ambiance_sounds.json configuration file and generates
Swift code that can be used at build time.

Usage:
    python3 generate_ambiance_sounds.py

The script expects to be run from the ios directory or with appropriate paths.
"""

import json
import os
import sys
from pathlib import Path

# Configuration
SCRIPT_DIR = Path(__file__).parent.resolve()
IOS_DIR = SCRIPT_DIR.parent.parent
RESOURCES_DIR = IOS_DIR / "NoNonsenseMeditation" / "Resources"
JSON_FILE = RESOURCES_DIR / "ambiance_sounds.json"
OUTPUT_FILE = IOS_DIR / "NoNonsenseMeditation" / "NoNonsenseMeditation" / "Core" / "Models" / "AmbianceSound.swift"

def escape_string(s: str) -> str:
    """Escape special characters in a Swift string literal."""
    return s.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t")

def swift_optional(value):
    """Convert a Python value to a Swift optional literal."""
    if value is None:
        return "nil"
    elif isinstance(value, str):
        return '"{}"'.format(escape_string(value))
    elif isinstance(value, bool):
        return "true" if value else "false"
    elif isinstance(value, (int, float)):
        return str(value)
    else:
        return str(value)

def generate_swift(sounds: list) -> str:
    """Generate Swift code from the sounds configuration."""
    
    # Generate the sounds array with proper struct initializers
    sounds_array = []
    for sound in sounds:
        # Generate proper struct initializer
        initializer = "AmbianceSound(id: \"{}\", " \
                      "displayName: \"{}\", " \
                      "iconName: \"{}\", " \
                      "description: \"{}\", " \
                      "filename: {}, " \
                      "fileExtension: {}, " \
                      "requiresFile: {}, " \
                      "isUserLibrary: {})".format(
                          escape_string(sound.get('id', '')),
                          escape_string(sound.get('displayName', '')),
                          escape_string(sound.get('iconName', '')),
                          escape_string(sound.get('description', '')),
                          swift_optional(sound.get('filename')),
                          swift_optional(sound.get('fileExtension')),
                          str(sound.get('requiresFile', False)).lower(),
                          str(sound.get('isUserLibrary', False)).lower()
                      )
        sounds_array.append("    " + initializer)
    
    sounds_list = ",\n".join(sounds_array)
    
    # Build the Swift code without using format() to avoid conflicts with {} in the template
    swift_code = """//
//  AmbianceSound.swift
//  NoNonsenseMeditation
//
//  AUTO-GENERATED FILE - DO NOT EDIT
//  Generated by: generate_ambiance_sounds.py
//  Source: Resources/ambiance_sounds.json
//

import Foundation

/// Represents an ambiance sound configuration for meditation sessions
/// Loaded from ambiance_sounds.json at build time
struct AmbianceSound: Identifiable, Codable, Sendable, Hashable {
    
    // MARK: - Properties
    
    /// Unique identifier for the sound (used for UserDefaults storage)
    let id: String
    
    /// User-facing display name
    let displayName: String
    
    /// SF Symbol icon name
    let iconName: String
    
    /// Short description of the sound
    let description: String
    
    /// Filename for the audio resource (without extension)
    let filename: String?
    
    /// File extension for the audio resource
    let fileExtension: String?
    
    /// Whether this sound requires an audio file from the bundle
    let requiresFile: Bool
    
    /// Whether this sound uses the user's music library
    let isUserLibrary: Bool
    
    // MARK: - Computed Properties
    
    /// Whether this sound uses the user's music library
    var usesUserLibrary: Bool { isUserLibrary }
}

// MARK: - Ambiance Sound Loader

/// Loads ambiance sounds from the generated configuration
enum AmbianceSoundLoader {
    
    /// All available ambiance sounds
    /// This array is generated at build time from ambiance_sounds.json
    static let allSounds: [AmbianceSound] = [
"""
    swift_code += sounds_list
    swift_code += """
    ]
    
    /// Find a sound by its ID
    /// - Parameter id: The unique identifier of the sound
    /// - Returns: The sound with the given ID, or nil if not found
    static func sound(withId id: String) -> AmbianceSound? {
        allSounds.first { $0.id == id }
    }
    
    /// The "none" sound option (silence)
    static let none: AmbianceSound = allSounds[0]
    
    /// The user library sound option
    static let userLibrary: AmbianceSound? = allSounds.first { $0.isUserLibrary }
}

// MARK: - UserDefaults Persistence

extension AmbianceSound {
    /// UserDefaults key for storing selected background sound
    private static let userDefaultsKey = "selectedBackgroundSound"
    
    /// Save the background sound ID to UserDefaults
    func saveToUserDefaults() {
        UserDefaults.standard.set(id, forKey: Self.userDefaultsKey)
    }
    
    /// Load the background sound from UserDefaults
    /// - Returns: The saved sound, or .none if not found
    static func loadFromUserDefaults() -> AmbianceSound {
        guard let rawValue = UserDefaults.standard.string(forKey: userDefaultsKey),
              let sound = AmbianceSoundLoader.sound(withId: rawValue) else {
            return AmbianceSoundLoader.none
        }
        return sound
    }
}
"""
    
    return swift_code

def main():
    """Main entry point."""
    print("Generating AmbianceSound.swift from ambiance_sounds.json...")
    
    # Verify JSON file exists
    if not JSON_FILE.exists():
        print("Error: JSON file not found at {}".format(JSON_FILE))
        sys.exit(1)
    
    # Read JSON configuration
    try:
        with open(JSON_FILE, 'r', encoding='utf-8') as f:
            sounds = json.load(f)
    except json.JSONDecodeError as e:
        print("Error: Invalid JSON in {}: {}".format(JSON_FILE, e))
        sys.exit(1)
    
    # Generate Swift code
    swift_code = generate_swift(sounds)
    
    # Write output file
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write(swift_code)
    
    print("Successfully generated: {}".format(OUTPUT_FILE))
    print("  - {} ambiance sounds configured".format(len(sounds)))

if __name__ == "__main__":
    main()
